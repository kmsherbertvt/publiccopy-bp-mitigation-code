var documenterSearchIndex = {"docs":
[{"location":"#AdaptBarren.jl-Documentation","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.jl Documentation","text":"","category":"section"},{"location":"","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.jl Documentation","text":"","category":"page"},{"location":"#Functions","page":"AdaptBarren.jl Documentation","title":"Functions","text":"","category":"section"},{"location":"","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.jl Documentation","text":"Modules = [AdaptBarren]","category":"page"},{"location":"#AdaptBarren.Operator","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.Operator","text":"Operator(paulis::Array{Pauli{UInt64},1}, coeffs::Array{ComplexF64,1})\n\nConstruct an operator which is a weighted sum of Pauli strings.\n\n\n\n\n\n","category":"type"},{"location":"#AdaptBarren.Operator-Tuple{Pauli}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.Operator","text":"Operator(p::Pauli)\n\nCreate an operator that is a single Pauli string with weight 1.0.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.Pauli","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.Pauli","text":"Pauli{T<:Unsigned}\n\nPauli mask representation of a Pauli string. This type is parametric on T so that smaller sized integers can be used to represent the Pauli string, if possible. This also performs a check that the given integers constitute a valid Pauli string.\n\nExamples\n\nPauli string: \"IIXYZYZIYIZ\"\n\nid:  11000001010 -> 1546\nx:  00100000000 -> 256\ny:  00010100100 -> 164\nz:  00001010001 -> 81\n\n\n\n\n\n","category":"type"},{"location":"#AdaptBarren.DeltaYStopper","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.DeltaYStopper","text":"DeltaYStopper(delta::Float64 = 1e-8, n_best::Int64 = 5)\n\nHalt the algorithm if the n_best many energies are all within delta of each other.\n\nThis is supposed to indicate that the algorithm has stalled in performance.\n\n\n\n\n\n","category":"function"},{"location":"#AdaptBarren.EnergyErrorPrinter-Tuple{Float64}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.EnergyErrorPrinter","text":"EnergyErrorPrinter(gse::Float64)\n\nPrint the difference between the energy at the last iteration and the ground state energy, given as the argument gse.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.EnergyPrinter-Tuple{}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.EnergyPrinter","text":"EnergyPrinter()\n\nPrint the energy returned at the last iteration.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.FloorStopper","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.FloorStopper","text":"FloorStopper(floor::Float64, delta::Float64 = 1e-8)\n\nHalt the algorithm if the current energy falls within delta of floor.\n\n\n\n\n\n","category":"function"},{"location":"#AdaptBarren.MaxGradientPrinter-Tuple{}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.MaxGradientPrinter","text":"MaxGradientPrinter()\n\nPrint the maximum gradient at each layer.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.MaxGradientStopper","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.MaxGradientStopper","text":"MaxGradientStopper(eps::Float64 = 1e-8)\n\nHalts the algorithm if the maximum gradient falls below eps.\n\n\n\n\n\n","category":"function"},{"location":"#AdaptBarren.OperatorIndexPrinter","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.OperatorIndexPrinter","text":"OperatorIndexPrinter(formatted_ops = nothing)\n\nAt each layer, indicate the operator chosen by the ADAPT criterion.\n\nIf formatted_ops === nothing, the index of each operator as it exists in the pool will be printed. If a list of strings is given, the string of that index will instead be printed.\n\n\n\n\n\n","category":"function"},{"location":"#AdaptBarren.ParameterPrinter-Tuple{}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.ParameterPrinter","text":"ParameterPrinter()\n\nPrints the optimal parameters at each iteration.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.ParameterStopper-Tuple{Int64}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.ParameterStopper","text":"ParameterStopper(max_pars::Int64)\n\nHalt the algorithm if the maximum number of parameters is exceeded.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.clump_degenerate_values-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Any}} where T<:Real","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.clump_degenerate_values","text":"clump_degenerate_values(v::Vector{T}, degen_tol = 1e-10) where T<:Real\n\nGiven a sorted vector v, produce a vector of vectors where the resulting elements are all within degen_tol of each other in absolute value.\n\nExamples\n\nGiven the vector [0, 1, 1, 2, 2, 2, 3], the clumped output should be [[0], [1, 1], [2, 2, 2], [3]].\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.commutator","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.commutator","text":"commutator(A::Operator, B::Operator, simplify::Bool = true)\n\nCompute the commutator [A,B] for operators A and B.\n\n\n\n\n\n","category":"function"},{"location":"#AdaptBarren.diagonal_operator_to_vector-Tuple{Operator}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.diagonal_operator_to_vector","text":"diagonal_operator_to_vector(O::Operator)\n\nReturn the diagonal of an operator which is diagonal in the computational basis.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.exp_val-Tuple{Operator, Vector{ComplexF64}, Array{ComplexF64}}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.exp_val","text":"exp_val(A::Operator, state::Array{ComplexF64,1}, tmp::Array{ComplexF64})\n\nCompute the expectation value <state|A|state>.\n\nThe tmp array is mutated, and state is left unchanged.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.fast_grad!-Union{Tuple{T}, Tuple{Operator, Any, Any, Any, Vector{ComplexF64}, Vector{ComplexF64}, Vector{ComplexF64}, Vector{ComplexF64}}} where T<:Unsigned","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.fast_grad!","text":"fast_grad!( ham::Operator, ansatz, pars, result, psi::Vector{ComplexF64}, sigma::Vector{ComplexF64}, tmp1::Vector{ComplexF64}, tmp2::Vector{ComplexF64}) where T <: Unsigned\n\nCompute the gradient of the VQE cost function using an efficient method.\n\nCounting matrix multiplications\n\nThe number of required matrix multiplications is 1 + N + |support(ham)| + N-1 + N*(1+1+1) = 2*N + 3*N = 5*N ~ O(N)\n\nThis could in principle be reduced to 3*N multiplications, but at this point I don't want to spend more time optimizing this.\n\nArguments\n\nham::Operator: Hamiltonian to compute the expectation value with respect to.\nansatz: List of generators for ansatz.\npars: Parameters used in the ansatz.\nresult: Vector to store the resulting gradient.\npsi::Vector{ComplexF64}: Temporary vector.\nsigma::Vector{ComplexF64}: Initial state for the ansatz.\ntmp1::Vector{ComplexF64}: Temporary vector.\ntmp2::Vector{ComplexF64: Temporary vector.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.finite_difference!-Union{Tuple{T}, Tuple{Operator, Array{Pauli{T}, 1}, Vector{Float64}, Vector{Float64}, Vector{ComplexF64}, Vector{ComplexF64}, Vector{ComplexF64}}, Tuple{Operator, Array{Pauli{T}, 1}, Vector{Float64}, Vector{Float64}, Vector{ComplexF64}, Vector{ComplexF64}, Vector{ComplexF64}, Float64}} where T<:Unsigned","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.finite_difference!","text":"finite_difference!(ham::Operator, ansatz::Vector{Pauli{T}}, pars::Vector{Float64}, result::Vector{Float64}, initial_state::Vector{ComplexF64}, tmp1::Vector{ComplexF64}, tmp2::Vector{ComplexF64}, eps::Float64 = 1e-8) where T <: Unsigned\n\nCompute the gradient of the VQE cost function using the finite difference method.\n\nArguments\n\nham::Operator: Hamiltonian to compute the expectation value with respect to.\nansatz: List of generators for ansatz.\npars: Parameters used in the ansatz.\nresult: Vector to store the resulting gradient.\ninitial_state::Vector{ComplexF64}: Initial state for the ansatz.\ntmp1::Vector{ComplexF64}: Temporary vector.\ntmp2::Vector{ComplexF64}: Temporary vector.\neps::Float64 = 1e-8: Small value to use for finite difference.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.get_energy_gap-Tuple{Operator}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.get_energy_gap","text":"get_energy_gap(h::Operator)\n\nCompute the difference beteween the largest and smallest eigenvalues of a given Hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.get_ground_state-Tuple{Operator}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.get_ground_state","text":"get_ground_state(h::Operator)\n\nCompute the smallest eigenvalue of an operator.\n\nCurrently only diagonal operators are supported.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.ground_state_overlap","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.ground_state_overlap","text":"ground_state_overlap(hamiltonian::Vector{Float64}, state::Vector{ComplexF64}, degen_tol = 1e-10)\n\nCompute the overlap between the given state and the ground state of a given operator.\n\nNote that if the given operator has degenerate ground states, the overlaps are summed over. Numerically, all states with energy E such that |E - E_0| <= degen_tol are said to be degenerate.\n\n\n\n\n\n","category":"function"},{"location":"#AdaptBarren.matrix_to_operator-Tuple{Any}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.matrix_to_operator","text":"matrix_to_operator(A::Array{ComplexF64,1})\n\nReturn the matrix A represented as an operator in the Pauli basis.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.max_cut_hamiltonian-Union{Tuple{T}, Tuple{Int64, Array{Tuple{Int64, Int64, T}, 1}}} where T<:Real","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.max_cut_hamiltonian","text":"max_cut_hamiltonian(n::Int, edges::Vector{Tuple{Int, Int, T}}) where T<:Real\n\nReturn the max cut Hamiltonian acting on n qubits which corresponds to the edge set edges.\n\nExamples\n\nElements of the edge set look like (1,2,5.0) corresponding to an edge between vertices 1 and 2 with edge weight 5.0.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.minimal_complete_pool-Tuple{Int64}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.minimal_complete_pool","text":"minimal_complete_pool(n::Int64)\n\nReturn the minimal complete pool on n qubits corresponding with the V pool in the qubit-ADAPT paper.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.num_qubits-Tuple{Operator}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.num_qubits","text":"num_qubits(O::Operator)\n\nCompute the number of qubits on which O acts non-trivially, including qubits with lower index than the maximum.\n\nFor example, a Pauli with Pauli string XYI would act on 3 qubits, but IYX would act on only 2 qubits.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.num_qubits-Tuple{Pauli}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.num_qubits","text":"num_qubits(P::Pauli)\n\nDetermine the number of qubits on which P acts non-trivially.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.one_local_pool_from_axes-Tuple{Int64, Vector{Int64}}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.one_local_pool_from_axes","text":"one_local_pool_from_axes(n::Int64, axes::Vector{Int64})\n\nReturn the pool on n qubits with single qubit operators corresponding to each element of axes.\n\nHas size n * |axes|.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.op_chop!","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.op_chop!","text":"op_chop!(A::Operator, tol::Float64 = 0.0)\n\nRemove terms inplace from an operator whose coefficients have coefficients with magnitude less than tol.\n\n\n\n\n\n","category":"function"},{"location":"#AdaptBarren.op_product-Tuple{Operator, Operator}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.op_product","text":"op_product(A::Operator, B::Operator)\n\nComputes the product of operators A and B.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.operator_to_matrix-Tuple{Operator}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.operator_to_matrix","text":"operator_to_matrix(O::Operator)\n\nCompute the matrix representation of a given operator.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.pauli_ansatz!-Union{Tuple{T}, Tuple{Any, Any, Vector{ComplexF64}, Vector{ComplexF64}}} where T<:Unsigned","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.pauli_ansatz!","text":"pauli_ansatz!(axes, pars, result::Array{ComplexF64,1}, tmp::Array{ComplexF64,1})\n\nEvolve result according to the given ansatz and angles.\n\nNote that result is the initial state, evolved inplace, and is also the resulting state. tmp is also mutated, but should be considered junk.\n\nArguments\n\naxes::Array{Pauli{T},1} where T<:UInt: The generators used in the ansatz.\npars::Array{Float64,1}: The angles of rotation for each of the generators.\nresult::Array{ComplexF64,1}: The state to be evolved.\ntmp::Array{ComplexF64,1}: A temporary vector.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.pauli_commute-Tuple{Pauli, Pauli}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.pauli_commute","text":"pauli_commute(P::Pauli, Q::Pauli)\n\nReturn whether Paulis P and Q compute.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.pauli_mult!-Tuple{Pauli, Vector{ComplexF64}, Vector{ComplexF64}}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.pauli_mult!","text":"pauli_mult!(pm::Pauli, state::Array{ComplexF64,1}, result::Array{ComplexF64,1})\n\nCompute the action of a Pauli string on a given statevector and store the result.\n\nNote that the result is stored result and state remains unchanged.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.pauli_product-Tuple{Pauli, Pauli}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.pauli_product","text":"pauli_product(P::Pauli, Q::Pauli)\n\nCompute the product of the operators P and Q and return the result.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.pauli_string_to_pauli","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.pauli_string_to_pauli","text":"pauli_string_to_pauli(ps::String)\n\nCreate a Pauli object from a given Pauli string.\n\nThe rightmost element of the string is interpreted as the first-indexed qubit, i.e. IIXY has the Y operator acting on qubit 1.\n\n\n\n\n\n","category":"function"},{"location":"#AdaptBarren.pauli_to_pauli_string-Union{Tuple{T}, Tuple{Pauli{T}, Int64}} where T<:Unsigned","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.pauli_to_pauli_string","text":"pauli_to_pauli_string(P::Pauli{T}, n::Int)\n\nCreate a Pauli string from the given Pauli.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.qaoa_layer!-Tuple{Vector{Float64}, Float64, Vector{ComplexF64}}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.qaoa_layer!","text":"qaoa_layer!(hamiltonian::Array{Float64,1}, gamma::Float64, result::Array{ComplexF64,1})\n\nGiven a diagonal operator (hamiltonian), evolve the state result by an angle gamma.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.random_regular_max_cut_hamiltonian-Tuple{Int64, Int64}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.random_regular_max_cut_hamiltonian","text":"random_regular_max_cut_hamiltonian(n::Int, k::Int; rng = _DEFAULT_RNG, weighted = true)\n\nReturn a random Hamiltonian for a max cut problem on n qubits.\n\nThe corresponding graph is degree k. If an RNG is provided, this will be used to sample the graph and edge weights. If weighted is true, the edge weights will be randomly sampled from the uniform distribution U(0,1).\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.random_two_local_ansatz","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.random_two_local_ansatz","text":"random_two_local_ansatz(n::Int64, k::Int64, axes=[0,1,2,3]; rng=_DEFAULT_RNG)\n\nProduce a pool on n qubits consisting of k randomly sampled Pauli strings that are two local and determined by the elements of axes.\n\n\n\n\n\n","category":"function"},{"location":"#AdaptBarren.two_local_pool","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.two_local_pool","text":"two_local_pool(n::Int64, axes=[0,1,2,3])\n\nReturns the two local pool on n qubits using elements of axes as terms in the Pauli strings.\n\n\n\n\n\n","category":"function"},{"location":"#AdaptBarren.two_local_pool_from_pairs-Tuple{Int64, Vector{Tuple{Int64, Int64}}}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.two_local_pool_from_pairs","text":"two_local_pool_from_pairs(n::Int64, pairs::Vector{Tuple{Int64, Int64}}; include_reverses = true)\n\nReturn the pool on n qubits with all two qubit Pauli strings defined in pairs.\n\nExamples\n\nThe pairs vector [(1,1), (2,3)] corresponds to all X_i X_j and Y_i Z_j terms acting on all pairs of qubits. If include_reverses is true, then terms like Y_j Z_i are included.\n\n\n\n\n\n","category":"method"},{"location":"#AdaptBarren.uniform_state-Tuple{Int64}","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.uniform_state","text":"uniform_state(n::Int)\n\nReturn the vector representation of the all |+> state on n qubits.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Tuple{Operator, Operator}","page":"AdaptBarren.jl Documentation","title":"Base.:*","text":"*(x::Operator, y::Operator)\n\nComputes x*y for operators x and y.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Tuple{Operator, Operator}","page":"AdaptBarren.jl Documentation","title":"Base.:+","text":"+(x::Operator, y::Operator)\n\nComputes x+y for operators x and y.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:--Tuple{Operator, Operator}","page":"AdaptBarren.jl Documentation","title":"Base.:-","text":"-(x::Operator, y::Operator)\n\nComputes x-y for operators x and y.\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"AdaptBarren.jl Documentation","title":"Index","text":"","category":"section"},{"location":"","page":"AdaptBarren.jl Documentation","title":"AdaptBarren.jl Documentation","text":"","category":"page"}]
}
